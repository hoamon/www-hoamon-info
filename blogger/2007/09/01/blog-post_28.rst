陣列特殊排序需求
================================================================================

Example: 排序 '140.120.109.1', '140.1.109.2', '14.120.109.1', '120.140.109.2'…等
ip 格式的文字串。這種排序的結果應是將 ip 切成 4 個部份後再來排序的。

::>>> a = [4,5,6,1,2,3]
    >>> a.sort()
    >>> print a
    [1,2,3,4,5,6]


上面的例子告訴我們，每個 list 都會有 sort 方法，而它的功能就是把陣列中元素作排序。如果陣列中元素有字串、另一個陣列、其他物件等， sort
方法一樣都可以排序，只是你對一個混合型態的陣列作排序，不容易有實質意義。

而如果陣列中的元素是單型態的，但它們的資料格式長得有點複雜，像是 ip 位置，那麼該如何排序呢!

::>>> def sort_by_ip(X, Y):
    ...     x_list = X.split('.')
    ...     y_list = Y.split('.')
    ...     for (i, x) in enumerate(x_list):
    ...         if int(x) > int(y_list[i]):
    ...             return 1
    ...         else:
    ...             return -1
    ...     return 0
    ...
    >>> ip = ['1.1.1.1', '140.120.109.1', '140.1.109.2', '14.120.109.1',
    '120.140.109.2']
    >>> ip.sort(sort_by_ip)
    >>> print ip
    ['1.1.1.1', '14.120.109.1', '120.140.109.2', '140.1.109.2',
    '140.120.109.1']


我 們利用一個自定的 sort_by_ip 方法來客製化我們的排序需求。陣列的 sort 方法，在執行時，會依序將陣列中的元素以兩個兩個為單位丟給
sort_by_ip 方法來處理，由 sort_by_ip 方法回傳出這兩個元素的大小，如果是前者為大，回傳值為 1 ，如果是後者為大，就回傳 -1
，相等則回傳 0 。

所以你也就不須煩惱 sort 方法是不是用 quicksort/bubble 演算法，只須考量兩個元素的大小是如何判定的。

當問題只縮小到判定兩者大小時，就十分簡單了，在 sort_by_ip 方法中，我們首先拿到兩個元素的值，然後以 split 方法將其斷成 4
個子元素，再來依序比較這 4 個子元素的大小即可。

再來談一個例子：[{'cost': 10, 'id': 3}, {'cost': 1, 'id': 13}, {'cost': 100, 'id':
33}, {'cost': 84, 'id': 4}]該如何排序，解答如下：

::def sort_by_cost(X, Y):
        if X['cost'] > Y['cost']: return 1
        elif X['cost']
        else: return 0


.. author:: default
.. categories:: chinese
.. tags:: python, math, cmclass
.. comments::